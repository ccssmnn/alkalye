# Progress Log

## 2026-01-09: Theme Schema Implementation

### What was done
- Implemented `Theme` schema in `src/schema/index.ts` with fields:
  - `version` (literal 1)
  - `name`, `author`, `description` (strings)
  - `type` (ThemeType enum: 'preview' | 'slideshow' | 'both')
  - `css` (co.plainText for large CSS content)
  - `template` (optional co.plainText for HTML templates)
  - `presets` (optional JSON string for slideshow presets)
  - `assets` (optional list of ThemeAsset)
  - `thumbnail` (optional co.image)
  - `createdAt`, `updatedAt` (dates)

- Implemented `ThemeAsset` schema for storing theme assets (fonts, images):
  - `name`, `mimeType` (strings)
  - `data` (co.fileStream for binary data)
  - `createdAt` (date)

- Implemented `ThemePreset` zod schema for slideshow color presets:
  - `name`, `appearance` (light/dark)
  - `colors` object with background, foreground, accent, and optional heading, link, codeBackground
  - Optional `fonts` object with title and body font families

- Added `themes: co.optional(co.list(Theme))` to `UserRoot` schema

- Added migration in `UserAccount.withMigration()` to initialize empty themes list for new and existing users

### PRD requirements completed
- [x] schema: "Theme schema stores uploaded theme data" - passes: true
- [x] schema: "Theme references stored as co.plainText for CSS content" - passes: true

### Notes for next steps
- The schema is now ready for the upload functionality
- Next priority should be implementing the Settings UI for theme upload and management
- The `ThemeType` enum and `ThemePreset` zod schema are exported for use in upload validation

## 2026-01-09: Theme Upload and Settings UI

### What was done
- Created `src/lib/theme-upload.ts` for parsing and validating theme zip files:
  - `parseThemeZip(file)` - parses a zip file and extracts all theme content
  - `validateThemeJson(content)` - validates theme.json manifest against schema
  - `ThemeJsonSchema` - zod schema for theme.json validation
  - Handles: theme.json manifest, CSS files, HTML templates, presets.json, fonts, thumbnails
  - Returns typed `ThemeUploadError` for different error conditions

- Added `ThemesSection` component to `src/routes/settings.tsx`:
  - Upload button with file input for .zip files
  - Loading state during upload
  - Error display with detailed validation errors
  - Empty state when no themes uploaded
  - List of uploaded themes showing name, type, and author
  - Delete button with confirmation dialog

- Updated settings query to include themes with CSS and assets loaded

### Files changed
- `src/lib/theme-upload.ts` (new file)
- `src/routes/settings.tsx` (added ThemesSection, updated imports and query)

### PRD requirements completed
- [x] upload: "Users can upload theme zip files in settings" - passes: true
- [x] upload: "Theme zip validation on upload" - passes: true
- [x] upload: "Theme assets are extracted and stored" - passes: true
- [x] settings: "Themes list displayed in settings" - passes: true
- [x] settings: "Theme can be deleted from settings" - passes: true

### Notes for next steps
- "Theme can be set as default" not implemented yet - requires adding default theme fields to Settings
- Thumbnail display in theme list not implemented yet (stored but not shown)
- Next priority: implement frontmatter parsing to apply themes to documents
- CSS asset URL rewriting (for fonts in CSS) will be needed when applying themes

## 2026-01-09: Frontmatter Theme Parsing

### What was done
- Created `src/lib/document-theme.ts` with utilities for parsing and resolving themes from frontmatter:
  - `getThemeName(content)` - extracts theme name from frontmatter `theme:` field
  - `getPresetName(content)` - extracts preset name from frontmatter `preset:` field
  - `findThemeByName(themes, name)` - case-insensitive theme lookup in user's themes list
  - `getThemePresets(theme)` - parses presets JSON from theme
  - `findPresetByName(theme, name)` - case-insensitive preset lookup within a theme
  - `useDocumentTheme(content)` - React hook that resolves theme and preset from document content

- The `useDocumentTheme` hook:
  - Returns `{ theme, preset, warning }` based on frontmatter
  - Handles case-insensitive theme name matching
  - Shows warning when theme is not found in user's themes list
  - Falls back to first preset when specified preset is not found
  - Skips `light`/`dark` values (handled by appearance system)
  - Loads themes with CSS and assets for rendering

### Files changed
- `src/lib/document-theme.ts` (new file)

### PRD requirements completed
- [x] frontmatter: "Theme can be specified in document frontmatter" - passes: true
- [x] frontmatter: "Preset can be specified for slideshow themes" - passes: true

### Notes for next steps
- The hook is ready to use in Preview and Slideshow components
- Next priority: integrate `useDocumentTheme` into Preview component to inject CSS
- Warning UI for missing themes should be added to preview/slideshow views
- CSS asset URL rewriting still needed for fonts/images referenced in theme CSS

## 2026-01-09: Preview Theme CSS Injection

### What was done
- Created `src/lib/theme-renderer.ts` with utilities for building theme CSS:
  - `buildThemeStyles(theme, preset)` - builds complete CSS including @font-face rules and preset variables
  - Creates blob URLs from theme font assets (co.fileStream)
  - Returns `ThemeStyles` object with css, fontFaceRules, presetVariables, and blobUrls
  - Properly handles cleanup of blob URLs when theme changes

- Integrated theme styles into `src/components/preview.tsx`:
  - Added `useDocumentTheme` hook to resolve theme from frontmatter
  - Added `useThemeStyles` custom hook that manages theme CSS and blob URL lifecycle
  - Injects theme CSS via `<style>` tag in preview
  - Injects @font-face rules for theme fonts with blob URLs
  - Injects preset CSS variables (--preset-background, --preset-foreground, etc.)
  - Shows warning banner when theme is not found in user's themes
  - Added `data-theme` attribute to article for theme-specific CSS targeting

- Theme CSS features:
  - Font assets are served via blob URLs created from Jazz fileStream
  - @font-face rules are generated automatically with correct format (woff2, woff, truetype, opentype)
  - font-display: swap for progressive font loading
  - Preset colors exposed as CSS variables for theme authors to use

### Files changed
- `src/lib/theme-renderer.ts` (new file)
- `src/components/preview.tsx` (added theme integration)

### PRD requirements completed
- [x] preview: "Preview component applies theme CSS" - passes: true
- [x] preview: "Preview loads theme fonts" - passes: true

### Notes for next steps
- "Preview uses custom HTML template when provided" not yet implemented
- Next priority could be: slideshow theme support, or custom HTML templates
- The same pattern (useDocumentTheme + buildThemeStyles) can be used for slideshow

## 2026-01-09: Slideshow Theme Support

### What was done
- Integrated theme styles into `src/components/slideshow.tsx`:
  - Added `useDocumentTheme` hook to resolve theme from frontmatter
  - Added `useThemeStyles` custom hook (same pattern as preview)
  - Injects theme CSS via `<style>` tag before slide container
  - Injects @font-face rules for theme fonts with blob URLs
  - Injects preset CSS variables (--preset-background, --preset-foreground, etc.)
  - Shows warning banner when theme is not found in user's themes
  - Added `data-theme` attribute to container for theme-specific CSS targeting

- Background/foreground color handling:
  - When a preset is available, uses CSS variables for background/foreground colors
  - Falls back to existing light/dark/system appearance handling when no preset
  - Renamed internal variable from `theme` to `appearanceTheme` to avoid confusion with custom theme

- Warning banner:
  - Shows absolute-positioned centered banner at top of slideshow
  - Same warning messages as preview (missing theme, missing preset fallback)

### Files changed
- `src/components/slideshow.tsx` (added theme integration)

### PRD requirements completed
- [x] slideshow: "Slideshow component applies theme CSS" - passes: true
- [x] slideshow: "Slideshow applies preset colors" - passes: true
- [x] slideshow: "Slideshow loads theme fonts" - passes: true

### Notes for next steps
- "Slideshow preset respects appearance mode" not yet implemented - requires connecting preset appearance to system theme
- CSS variables feature ("Theme CSS can use predefined CSS variables") is partially done - preset colors work but need documentation
- Next priorities could be: appearance mode handling, security sanitization, or default theme settings

## 2026-01-09: Default Theme Settings

### What was done
- Updated `Settings` schema in `src/schema/index.ts` to include:
  - `defaultPreviewTheme: z.string().optional()` - name of default preview theme
  - `defaultSlideshowTheme: z.string().optional()` - name of default slideshow theme

- Updated `useDocumentTheme` hook in `src/lib/document-theme.ts`:
  - Added `mode` parameter: `'preview' | 'slideshow'` (defaults to 'preview')
  - Falls back to default theme from settings when no theme specified in frontmatter
  - Silently falls back if default theme was deleted (no warning shown)
  - Only shows warning for missing themes explicitly specified in frontmatter
  - Updated `themesQuery` to also load settings for default theme lookup

- Added `DefaultThemeSettings` component in `src/routes/settings.tsx`:
  - Shows dropdown selectors for default preview and slideshow themes
  - Filters themes by type (preview, slideshow, or both)
  - "None" option clears the default
  - Only appears when there are themes of the appropriate type

- Updated Preview component to pass `mode: "preview"` to useDocumentTheme
- Updated Slideshow component to pass `mode: "slideshow"` to useDocumentTheme

### Files changed
- `src/schema/index.ts` (added defaultPreviewTheme, defaultSlideshowTheme to Settings)
- `src/lib/document-theme.ts` (added mode parameter and default theme fallback)
- `src/routes/settings.tsx` (added DefaultThemeSettings component)
- `src/components/preview.tsx` (pass mode to useDocumentTheme)
- `src/components/slideshow.tsx` (pass mode to useDocumentTheme)

### PRD requirements completed
- [x] settings: "Theme can be set as default" - passes: true

### Notes for next steps
- Default themes work via theme name lookup (not by ID), so renaming a theme will break the default
- Remaining priority features: custom HTML templates, appearance mode handling, security, performance, UX picker

## 2026-01-09: Custom HTML Template Support for Preview

### What was done
- Added custom HTML template rendering support to the preview component
- Templates use the `data-document` attribute as a placeholder for injected content

- Updated `ThemesQuery` type in `src/lib/document-theme.ts` to include `template: true`
- Updated `themesQuery` object to load template content alongside CSS and assets

- Added `renderTemplateWithContent(template, content)` function in `src/lib/theme-renderer.ts`:
  - Parses template HTML using DOMParser
  - Finds element with `[data-document]` attribute as injection point
  - Injects rendered markdown HTML into the placeholder
  - Returns the body's innerHTML for rendering in React

- Updated `PreviewContent` in `src/components/preview.tsx`:
  - Gets template string from theme via `documentTheme.theme?.template?.toString()`
  - Combines all segment HTML when template is present
  - Uses `renderTemplateWithContent` to inject content into template
  - Renders templated content with `dangerouslySetInnerHTML` when template exists
  - Falls back to default segment-by-segment rendering when no template

### Files changed
- `src/lib/document-theme.ts` (added template to ThemesQuery and themesQuery)
- `src/lib/theme-renderer.ts` (added renderTemplateWithContent function)
- `src/components/preview.tsx` (added template rendering path)

### PRD requirements completed
- [x] preview: "Preview uses custom HTML template when provided" - passes: true

### Notes for next steps
- Security sanitization not yet implemented - templates accept arbitrary HTML (PRD security requirements still pending)
- Template-mode doesn't render inline Jazz images (only text segments combined)
- Next priorities: appearance mode handling for slideshow, CSS variables documentation, security sanitization

## 2026-01-09: Theme Security Sanitization

### What was done
- Added DOMPurify dependency for HTML sanitization
- Created `src/lib/theme-sanitize.ts` with CSS and HTML sanitization functions:
  - `sanitizeCss(css)` - Removes dangerous CSS patterns:
    - javascript: URLs
    - expression() (IE CSS exploit)
    - -moz-binding (Firefox XBL exploit)
    - behavior: (IE HTC exploit)
    - vbscript: URLs
    - @import with external http/https URLs
    - @import with protocol-relative URLs
    - data:text/html URLs (XSS vector)
  - `sanitizeHtml(html)` - Uses DOMPurify to remove dangerous HTML:
    - <script>, <iframe>, <object>, <embed>, <form>, <button>, <base> tags
    - All event handler attributes (onclick, onload, onmouseover, etc.)
    - javascript: URLs in href/src attributes
    - Preserves safe HTML structure and data-* attributes for templates
  - Both functions return `SanitizeResult` with sanitized content and removal info

- Integrated sanitization into theme upload in `src/lib/theme-upload.ts`:
  - CSS is sanitized via `sanitizeCss()` before storage
  - HTML templates are sanitized via `sanitizeHtml()` before storage
  - Sanitization happens during the `parseThemeZip()` function

- Added comprehensive test suite in `src/lib/theme-sanitize.test.ts`:
  - 14 CSS sanitization tests covering all dangerous patterns
  - 19 HTML sanitization tests covering XSS vectors and attribute preservation
  - Tests require jsdom environment (run via vitest, not bun test)

- Updated `package.json` check:test script to run theme-sanitize tests via vitest
  (DOMPurify doesn't work properly with happy-dom used by bun test)

### Files changed
- `package.json` (added dompurify, @types/dompurify, updated check:test script)
- `src/lib/theme-sanitize.ts` (new file)
- `src/lib/theme-sanitize.test.ts` (new file)
- `src/lib/theme-upload.ts` (integrated sanitization)

### PRD requirements completed
- [x] security: "Theme CSS is sanitized" - passes: true
- [x] security: "Theme HTML template is sanitized" - passes: true

### Notes for next steps
- Sanitization happens at upload time, so existing themes are not sanitized
- For existing themes, users would need to re-upload to get sanitization
- Remaining priorities: CSS variables documentation, appearance mode handling, performance caching, UX picker

## 2026-01-09: CSS Variables for Theme Authors

### What was done
- Extended `ThemePreset` schema in `src/schema/index.ts` to support multiple accent colors:
  - Added `accents: z.array(z.string()).optional()` to the colors object
  - Allows theme authors to define accent-2 through accent-6 colors in presets.json

- Updated `buildThemeStyles` in `src/lib/theme-renderer.ts` to inject CSS variables:
  - `--preset-accent-1` (same as --preset-accent, for consistency)
  - `--preset-accent-2` through `--preset-accent-6` (from accents array)
  - `--theme-background`, `--theme-foreground`, `--theme-accent` (aliases for theme authors)

### Available CSS Variables for Theme Authors
When a theme preset is active, the following CSS variables are injected into `:root`:

**Preset colors:**
- `--preset-background` - Background color from preset
- `--preset-foreground` - Foreground/text color from preset
- `--preset-accent` - Primary accent color
- `--preset-accent-1` through `--preset-accent-6` - Accent color palette
- `--preset-heading` - Heading color (if defined)
- `--preset-link` - Link color (if defined)
- `--preset-code-background` - Code block background (if defined)

**Preset fonts:**
- `--preset-font-title` - Title/heading font family (if defined)
- `--preset-font-body` - Body text font family (if defined)

**Theme aliases:**
- `--theme-background` - Alias for --preset-background
- `--theme-foreground` - Alias for --preset-foreground
- `--theme-accent` - Alias for --preset-accent

**Preset metadata:**
- `--preset-appearance` - "light" or "dark"

### Files changed
- `src/schema/index.ts` (added accents array to ThemePreset colors)
- `src/lib/theme-renderer.ts` (inject accent palette and theme alias variables)

### PRD requirements completed
- [x] css-variables: "Theme CSS can use predefined CSS variables" - passes: true
- [x] css-variables: "Preset colors are injected as CSS variables" - passes: true

### Notes for next steps
- Theme authors can now use `var(--theme-background)` etc. in their CSS
- Accent palette allows for richer color schemes (up to 6 accent colors)
- Remaining priorities: appearance mode handling, performance caching, UX picker, fallback handling

## 2026-01-09: Graceful Fallback for Missing and Corrupted Themes

### What was done
- Verified and marked "Missing theme falls back gracefully" as complete:
  - `useDocumentTheme` hook already returns warning when theme not found
  - Preview and Slideshow components already display warning banners
  - Documents render with default styles when theme is missing
  - Warning message: "Theme '{name}' not found. Upload it in Settings > Themes."

- Implemented corrupted theme data handling:
  - Added `tryBuildThemeStyles()` wrapper in `src/lib/theme-renderer.ts`:
    - Catches any errors during theme style building
    - Logs errors to console for debugging: `[Theme Error] Failed to build styles for theme "{name}": ...`
    - Returns result object with `{ ok: true, styles }` or `{ ok: false, error }`
  - Added `tryRenderTemplateWithContent()` wrapper for template rendering:
    - Catches errors during HTML template parsing and injection
    - Handles missing `[data-document]` placeholder gracefully
    - Logs errors to console for debugging
  - Updated `useThemeStyles` hooks in both preview.tsx and slideshow.tsx:
    - Now returns `{ styles, error }` instead of just `styles`
    - Falls back to null styles on error (uses default styling)
  - Added error banners in both Preview and Slideshow components:
    - Red destructive-colored banner distinct from warning banner
    - Shows error message with "Using default styles" notice
    - Users can still edit and view documents normally

### Files changed
- `src/lib/theme-renderer.ts` (added tryBuildThemeStyles, tryRenderTemplateWithContent, ThemeRenderResult type)
- `src/components/preview.tsx` (updated useThemeStyles, added error banner)
- `src/components/slideshow.tsx` (updated useThemeStyles, added error banner)
- `prd.json` (marked both fallback requirements as passes: true)

### PRD requirements completed
- [x] fallback: "Missing theme falls back gracefully" - passes: true
- [x] fallback: "Corrupted theme data handled gracefully" - passes: true

### Notes for next steps
- Both fallback features are now complete
- The error handling logs to console.error for debugging
- Error messages are user-friendly and explain that default styles are being used
- Remaining priorities: appearance mode handling, performance caching, UX picker, compatibility imports

## 2026-01-09: Slideshow Preset Respects Appearance Mode

### What was done
- Implemented automatic preset selection based on appearance mode (light/dark)
- Presets with matching `appearance` field are automatically selected when no preset is explicitly specified in frontmatter

- Added `findPresetByAppearance(theme, appearance)` function in `src/lib/document-theme.ts`:
  - Finds the first preset in a theme that matches the given appearance ("light" or "dark")
  - Returns null if no matching preset is found

- Updated `useDocumentTheme` hook in `src/lib/document-theme.ts`:
  - Added optional `appearance` parameter (type: "light" | "dark" | null)
  - When no preset is specified in frontmatter but appearance is provided, auto-selects a matching preset
  - Falls back to first preset if no appearance-matching preset exists
  - When preset IS specified in frontmatter, that explicit selection takes priority

- Updated `Slideshow` component in `src/components/slideshow.tsx`:
  - Computes effective appearance from frontmatter override (`theme: light/dark`) or system theme
  - Passes effective appearance to `useDocumentTheme` for auto-selection
  - System theme changes trigger re-render with new preset selection

### How it works
1. User creates presentation with theme that has light and dark presets
2. If no preset specified in frontmatter:
   - System is in light mode → light preset automatically selected
   - System is in dark mode → dark preset automatically selected
3. Frontmatter `theme: light` or `theme: dark` overrides system preference
4. When system theme changes, preset automatically switches (smooth transition via React re-render)
5. Explicit `preset: MyPreset` in frontmatter always takes priority

### Files changed
- `src/lib/document-theme.ts` (added findPresetByAppearance, updated useDocumentTheme signature and logic)
- `src/components/slideshow.tsx` (compute effective appearance, pass to useDocumentTheme)
- `prd.json` (marked slideshow appearance mode as passes: true)

### PRD requirements completed
- [x] slideshow: "Slideshow preset respects appearance mode" - passes: true

### Notes for next steps
- Performance caching not implemented yet (themes load fresh on each navigation)
- UX picker (theme selection in editor toolbar) not implemented
- Compatibility imports (iA Writer/Presenter) not implemented
- Export features (PDF with theme, theme zip export) not implemented
- Collaboration features (theme sharing) not implemented

## 2026-01-09: Theme Performance Caching

### What was done
- Implemented a global in-memory cache for theme styles in `src/lib/theme-renderer.ts`:
  - Cache keys are `themeId:presetName` for unique theme+preset combinations
  - Cache entries store built styles and theme's `updatedAt` timestamp for invalidation
  - When a theme is updated (new `updatedAt` timestamp), cache is automatically invalidated
  - Old blob URLs are revoked when cache entries are replaced (prevents memory leaks)

- Added new functions to theme-renderer.ts:
  - `getCachedThemeStyles(theme, preset)` - Returns cached styles or builds and caches new ones
  - `tryCachedThemeStyles(theme, preset)` - Safe wrapper with error handling (returns ThemeRenderResult)
  - `cleanupThemeCache(themeId)` - Removes all cache entries for a theme (for theme deletion)

- Updated `useThemeStyles` hook in both preview.tsx and slideshow.tsx:
  - Now uses `tryCachedThemeStyles` instead of `tryBuildThemeStyles`
  - Removed manual blob URL cleanup (cache handles this now)
  - Simplified hook logic since cache manages lifecycle

### How caching works
1. First load: Theme styles are built and cached with key `themeId:presetName`
2. Subsequent loads: Cache returns existing styles immediately (no blob URL recreation)
3. Theme update: `updatedAt` timestamp mismatch triggers rebuild and cache update
4. Old cache entries: Blob URLs are revoked before replacement to prevent memory leaks
5. Cache is global: Same theme styles are shared across all documents using that theme

### Performance benefits
- Navigating between documents with the same theme reuses cached blob URLs
- Switching between light/dark presets of the same theme is instant
- No redundant blob URL creation for repeated theme loads
- Memory-efficient: old blob URLs are properly cleaned up

### Files changed
- `src/lib/theme-renderer.ts` (added cache, getCachedThemeStyles, tryCachedThemeStyles, cleanupThemeCache)
- `src/components/preview.tsx` (updated useThemeStyles to use cache)
- `src/components/slideshow.tsx` (updated useThemeStyles to use cache)
- `prd.json` (marked performance caching as passes: true)

### PRD requirements completed
- [x] performance: "Themes are cached after first load" - passes: true

### Notes for next steps
- "Large theme files don't block rendering" could be next performance improvement (async loading)
- UX picker (theme selection in editor toolbar) not implemented
- Compatibility imports (iA Writer/Presenter) not implemented
- Export features (PDF with theme, theme zip export) not implemented
- Collaboration features (theme sharing) not implemented

## 2026-01-09: Non-Blocking Theme Loading for Large Files

### What was done
- Implemented async theme style building to prevent large themes from blocking rendering
- Theme styles are now loaded asynchronously, allowing content to render immediately

- Added async functions in `src/lib/theme-renderer.ts`:
  - `buildThemeStylesAsync(theme, preset)` - Async version that yields to main thread
  - `getCachedThemeStylesAsync(theme, preset)` - Async version with caching
  - `tryCachedThemeStylesAsync(theme, preset)` - Safe async wrapper with error handling
  - `buildPresetVariables(preset)` - Extracted preset variable building for reuse
  - `yieldToMain()` - Helper that yields to main thread via setTimeout(0)

- Async building features:
  - Preset CSS variables are built first (fast, needed for initial colors)
  - Yields to main thread before processing fonts
  - Yields every 3 fonts to keep UI responsive during many-font themes
  - Font blob URLs are created progressively, not all at once

- Updated `useThemeStyles` hooks in both preview.tsx and slideshow.tsx:
  - Now uses `tryCachedThemeStylesAsync` instead of sync version
  - Returns `isLoading` state alongside `styles` and `error`
  - Proper cancellation handling for async operations
  - Uses async .then() pattern to avoid blocking

- Added CSS transitions to prevent visible layout shift:
  - Transition styles injected before theme CSS: `color 150ms ease-out, background-color 150ms ease-out`
  - Applied to elements with `[data-theme]` attribute
  - Smooth transition when theme styles apply after async load

- Fonts already use `font-display: swap` (from previous work) for progressive loading

### How non-blocking loading works
1. User opens document with theme
2. Content renders immediately with default styles
3. `useThemeStyles` hook starts async style building
4. Preset variables built first (instant color theming)
5. Font blob URLs created progressively, yielding between batches
6. When complete, styles injected with smooth CSS transition
7. Fonts load asynchronously due to `font-display: swap`

### Files changed
- `src/lib/theme-renderer.ts` (added async functions, buildPresetVariables, yieldToMain)
- `src/components/preview.tsx` (async useThemeStyles, CSS transitions)
- `src/components/slideshow.tsx` (async useThemeStyles, CSS transitions)
- `prd.json` (marked non-blocking rendering as passes: true)

### PRD requirements completed
- [x] performance: "Large theme files don't block rendering" - passes: true

### Notes for next steps
- UX picker (theme selection in editor toolbar) not implemented
- Compatibility imports (iA Writer/Presenter) not implemented
- Export features (PDF with theme, theme zip export) not implemented
- Collaboration features (theme sharing) not implemented

## 2026-01-09: Theme Picker in Editor Toolbar

### What was done
- Added `setTheme(content, themeName)` function to `src/editor/frontmatter.ts`:
  - Sets or updates the `theme:` field in frontmatter
  - Pass `null` or empty string to remove the theme field
  - Creates frontmatter if it doesn't exist
  - Removes empty frontmatter when theme is the only field being removed

- Created `ThemePicker` component in `src/components/theme-picker.tsx`:
  - Dropdown button with Palette icon in the editor toolbar
  - Loads user's themes via useAccount hook
  - Groups themes by type (Preview Themes / Slideshow Themes)
  - Shows checkmark on currently selected theme
  - "Remove theme" option when a theme is already set
  - Disabled state when no themes available (tooltip explains to upload in Settings)
  - Only visible on desktop (hidden on mobile via `hidden md:contents`)

- Integrated ThemePicker into `src/components/editor-toolbar.tsx`:
  - Added `content` and `onThemeChange` props to EditorToolbarProps
  - ThemePicker appears after the Link button in edit mode
  - Calls onThemeChange with new content when theme is selected

- Updated document routes to pass theme-related props:
  - `src/routes/doc.$id.index.tsx`: passes content and onThemeChange
  - `src/routes/spaces.$spaceId.doc.$id.index.tsx`: passes content and onThemeChange

- Added comprehensive tests for `setTheme` in `src/editor/frontmatter.test.ts`:
  - 8 new test cases covering add, update, remove, and edge cases

### Files changed
- `src/editor/frontmatter.ts` (added setTheme function)
- `src/editor/frontmatter.test.ts` (added setTheme tests)
- `src/components/theme-picker.tsx` (new file)
- `src/components/editor-toolbar.tsx` (added ThemePicker integration)
- `src/routes/doc.$id.index.tsx` (pass content/onThemeChange to toolbar)
- `src/routes/spaces.$spaceId.doc.$id.index.tsx` (pass content/onThemeChange to toolbar)
- `prd.json` (marked theme picker as passes: true)

### PRD requirements completed
- [x] ux: "Theme picker in editor toolbar" - passes: true

### Notes for next steps
- "Theme preview before applying" (hover preview) not implemented - would require live preview on hover
- "Preset picker for slideshow themes" not implemented - would allow selecting presets from toolbar
- Compatibility imports (iA Writer/Presenter) not implemented
- Export features (PDF with theme, theme zip export) not implemented
- Collaboration features (theme sharing) not implemented

## 2026-01-09: Preset Picker for Slideshow Themes

### What was done
- Added `setPreset(content, presetName)` function to `src/editor/frontmatter.ts`:
  - Sets or updates the `preset:` field in frontmatter
  - Pass `null` or empty string to remove the preset field
  - Creates frontmatter if it doesn't exist
  - Removes empty frontmatter when preset is the only field being removed

- Created `PresetPicker` component in `src/components/preset-picker.tsx`:
  - Dropdown button with Paintbrush icon in the editor toolbar
  - Only visible when a slideshow theme with presets is selected
  - Groups presets by appearance (Light/Dark with sun/moon icons)
  - Shows color swatch for each preset's background color
  - Shows checkmark on currently selected preset
  - "Remove preset (use auto)" option when a preset is already set
  - Auto-hides when no presets are available or when theme is preview-only

- Integrated PresetPicker into `src/components/editor-toolbar.tsx`:
  - Appears next to ThemePicker in edit mode (desktop only)
  - Uses same `onThemeChange` callback since it modifies frontmatter content

- Added comprehensive tests in `src/editor/frontmatter.test.ts`:
  - 8 new test cases covering add, update, remove, and edge cases for setPreset

### How it works
1. User opens a presentation document
2. User selects a slideshow theme via ThemePicker
3. If theme has presets, PresetPicker button appears next to ThemePicker
4. User clicks PresetPicker to see available presets grouped by light/dark
5. User selects a preset
6. `preset: PresetName` is added to document frontmatter
7. Slideshow renders with selected preset's colors and fonts
8. User can remove preset to return to automatic appearance-based selection

### Files changed
- `src/editor/frontmatter.ts` (added setPreset function)
- `src/editor/frontmatter.test.ts` (added setPreset tests)
- `src/components/preset-picker.tsx` (new file)
- `src/components/editor-toolbar.tsx` (added PresetPicker integration)
- `prd.json` (marked preset picker as passes: true)

### PRD requirements completed
- [x] ux: "Preset picker for slideshow themes" - passes: true

### Notes for next steps
- "Theme preview before applying" (hover preview) not implemented - would require live preview on hover
- Compatibility imports (iA Writer/Presenter) not implemented
- Export features (PDF with theme, theme zip export) not implemented
- Collaboration features (theme sharing) not implemented

## 2026-01-09: Theme Preview Before Applying

### What was done
- Added hover preview functionality to the theme picker in the editor toolbar
- When hovering over a theme option, a tooltip appears showing:
  - Theme thumbnail image (if uploaded)
  - Theme name
  - Theme author (if provided)
  - Theme description (if provided)
- Current theme is indicated with a checkmark in the dropdown

- Updated `themesResolve` query in `src/components/theme-picker.tsx`:
  - Changed from `{ root: { themes: true } }` to `{ root: { themes: { $each: { thumbnail: true } } } }`
  - This ensures thumbnail images are loaded alongside theme data

- Updated `ThemeMenuItem` component:
  - Added hover state tracking via `useState`
  - Wrapped dropdown item in a `Tooltip` component with controlled `open` state
  - Tooltip appears on the left side of the dropdown with 8px offset
  - Shows thumbnail in aspect-video container with bg-muted background
  - Shows theme name, author, and description in a formatted card below thumbnail
  - Tooltip only appears when theme has preview content (thumbnail or description)

### Files changed
- `src/components/theme-picker.tsx` (added hover preview functionality)
- `prd.json` (marked theme preview as passes: true)

### PRD requirements completed
- [x] ux: "Theme preview before applying" - passes: true

### Notes for next steps
- Compatibility imports (iA Writer/Presenter) not implemented
- Export features (PDF with theme, theme zip export) not implemented
- Collaboration features (theme sharing) not implemented

## 2026-01-09: Theme Export as Zip (TypeScript fixes)

### What was done
- Fixed TypeScript errors in `src/lib/theme-export.ts` that were preventing compilation
- Updated type imports and query structure to match Jazz-tools patterns

- Fixed issues:
  1. Changed `co.fileStream.Loaded` to `FileStream` (correct type import from jazz-tools)
  2. Changed `for (let asset of theme.assets)` to `for (let asset of [...theme.assets])` (spread to array for iteration)
  3. Changed `thumbnail: true` to `thumbnail: { original: true }` in query (need to load original FileStream)
  4. Changed `await theme.thumbnail.toBlob()` to `theme.thumbnail.original.toBlob()` (images have .original property)
  5. Removed unnecessary `await` from `fileStream.toBlob()` (returns Blob | undefined, not Promise)
  6. Added proper `$isLoaded` checks before accessing loaded properties

- Updated `src/routes/settings.tsx` settings query to include `thumbnail: { original: true }` to match export query

### How theme export works
1. User clicks the Download button on a theme in Settings > Themes
2. `exportTheme()` function creates a JSZip archive containing:
   - `theme.json` - manifest file with metadata (name, type, author, css path, etc.)
   - `styles.css` - the theme's CSS content
   - `template.html` - custom HTML template (if present)
   - `presets.json` - color presets wrapped as `{ presets: [...] }` (if present)
   - `fonts/` - folder with font files (woff2, ttf, etc.) with proper extensions
   - `thumbnail.png` (or other format) - theme preview image (if present)
3. Zip is downloaded with sanitized filename (theme name + .zip)

### Files changed
- `src/lib/theme-export.ts` (fixed TypeScript errors, updated query and types)
- `src/routes/settings.tsx` (updated settingsQuery to include thumbnail.original)
- `prd.json` (marked theme export as passes: true)

### PRD requirements completed
- [x] export: "Theme can be exported as zip" - passes: true

### Notes for next steps
- "Theme is included in PDF export" not implemented (requires browser print integration)
- Compatibility imports (iA Writer/Presenter) not implemented
- Collaboration features (theme sharing) not implemented

## 2026-01-09: iA Writer Template Import Compatibility

### What was done
- Implemented iA Writer template (.iatemplate) import support in `src/lib/theme-upload.ts`
- The system now automatically detects and parses iA Writer templates when uploading a zip file

- Added `findIAWriterPlist(zip)` function to detect iA Writer bundle structure:
  - Looks for `Contents/Info.plist` at root or one level deep
  - Recognizes standard iA Writer bundle structure: `TemplateName.iatemplate/Contents/Info.plist`

- Added `parsePlist(content)` function for XML plist parsing:
  - Extracts `CFBundleName` (theme display name)
  - Extracts `IATemplateDocumentFile` (main template filename without .html extension)
  - Extracts `IATemplateDescription` (optional description)
  - Extracts `IATemplateAuthor` (optional author name)
  - Simple regex-based parser handles standard Apple plist format

- Added `extractCssPathsFromHtml(html)` function:
  - Extracts CSS file paths from `<link rel="stylesheet" href="...">` tags
  - Filters out external URLs (http/https/protocol-relative)

- Added `extractImportsFromCss(css, basePath, zip)` function:
  - Extracts `@import` paths from CSS files
  - Resolves relative paths within the Resources folder
  - Only includes imports that exist in the zip

- Added `parseIAWriterTemplate(zip, plistPath)` function:
  - Reads Info.plist and validates required fields
  - Locates and reads document.html template from Resources folder
  - Collects all CSS files (from HTML links and @import statements)
  - Inlines @import statements to create a single combined CSS file
  - Extracts font assets (.woff2, .woff, .ttf, .otf) from Resources folder
  - Sanitizes both HTML and CSS before returning
  - Returns ParsedTheme with type: "preview" (iA Writer templates are always preview-only)

- Updated `parseThemeZip()` to check for iA Writer format before standard theme.json format:
  - If `Contents/Info.plist` is found, routes to `parseIAWriterTemplate()`
  - Otherwise continues with standard theme.json parsing

### How iA Writer template import works
1. User uploads a `.iatemplate.zip` file in Settings > Themes
2. System detects `Contents/Info.plist` in the bundle structure
3. Parses Info.plist to get name, author, description, and document file
4. Reads document.html template (uses `data-document` attribute for content - already compatible!)
5. Extracts all CSS from linked stylesheets and @import statements
6. Combines CSS into single file with source comments
7. Extracts any font files from Resources folder
8. Returns as a preview-type theme ready for storage

### Files changed
- `src/lib/theme-upload.ts` (added iA Writer compatibility layer)
- `prd.json` (marked iA Writer import as passes: true)

### PRD requirements completed
- [x] compatibility: "iA Writer template zip can be imported" - passes: true

### Notes for next steps
- iA Presenter theme import still not implemented (different structure with template.json and presets)
- "Theme is included in PDF export" not implemented
- Collaboration features (theme sharing) not implemented

## 2026-01-09: iA Presenter Theme Import Compatibility

### What was done
- Implemented iA Presenter theme import support in `src/lib/theme-upload.ts`
- The system now automatically detects and parses iA Presenter themes when uploading a zip file

- Added `findIAPresenterTemplate(zip)` function to detect iA Presenter bundle structure:
  - Looks for `template.json` at root or one level deep
  - Only triggers when `theme.json` is NOT present (avoids conflict with standard format)

- Added `IAPresenterTemplateSchema` zod schema for template.json validation:
  - `name` (required) - theme display name
  - `author` (optional) - theme creator
  - `description` (optional) - theme description
  - `css` (optional) - path to CSS file
  - `presets` (optional) - path to presets.json

- Added `parseIAPresenterTheme(zip, templateJsonPath)` function:
  - Reads and validates template.json
  - Locates CSS file (checks template.json css field, then common names: styles.css, theme.css, style.css)
  - Reads and converts presets.json if available
  - Extracts font assets (.woff2, .woff, .ttf, .otf) from theme folder
  - Looks for thumbnail images (thumbnail.png/jpg, preview.png/jpg)
  - Sanitizes CSS before returning
  - Returns ParsedTheme with type: "slideshow" (iA Presenter themes are always slideshow)

- Added `convertIAPresenterPreset(preset)` function:
  - Converts various iA Presenter preset formats to our ThemePreset format
  - Handles different field naming conventions (background/backgroundColor/bg, etc.)
  - Auto-detects appearance (light/dark) from preset data or by analyzing background color luminance
  - Extracts optional colors: heading, link, codeBackground
  - Extracts additional accent colors (accent2-accent6)
  - Extracts font settings (titleFont, bodyFont)

- Added helper functions:
  - `extractColor(obj, keys)` - tries multiple field names to find a color value
  - `isColorDark(color)` - determines if a hex color is dark (for appearance inference)

- Updated `parseThemeZip()` to check for iA Presenter format:
  - Checks after iA Writer format but before standard theme.json format
  - If template.json is found (without theme.json), routes to iA Presenter parsing

### How iA Presenter theme import works
1. User uploads a `.iapresentertheme.zip` file in Settings > Themes
2. System detects `template.json` without `theme.json`
3. Parses template.json to get name, author, description, css path, presets path
4. Reads CSS file (tries multiple common names)
5. Reads presets.json and converts each preset to our format
6. Extracts font files from theme folder
7. Looks for thumbnail image
8. Returns as a slideshow-type theme ready for storage

### Files changed
- `src/lib/theme-upload.ts` (added iA Presenter compatibility layer)
- `prd.json` (marked iA Presenter import as passes: true)

### PRD requirements completed
- [x] compatibility: "iA Presenter theme can be imported" - passes: true

### Notes for next steps
- "Theme is included in PDF export" not implemented (requires browser print integration)
- Collaboration features (theme sharing) not implemented
- "Theme reference in document is portable" not implemented
